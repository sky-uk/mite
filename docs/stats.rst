========================
Customizing miteʼs stats
========================

There are two components of the mite pipeline that are concerned with
the reporting of test data: the stats component and the prometheus
exporter.  The prometheus exporter works in a fully automatic way, based
on the behavior of the stats component.  Therefore, when customizing the
statistics that mite exports, it is sufficient to work on the stats
component; the prometheus exporter will do the right thing.

Registering stats for a scenario
--------------------------------

In addition to the mite core statistics, the http statistics are always
available.  In order to pull in additional statistics, you will need to
use the ``with_stats`` decorator on your scenario function, passing it
the name(s) of the modules with custom stats that you want to be
included:

.. code-block:: python

   from mite.stats import with_stats

   @with_stats("mite_selenium")
   def my_scenario(config):
       return [...a list of journeys...]

Once you have set up the scenario function in this way, you will also
need to pass its name on the command line of the stats component:

.. code-block:: shell

   mite stats --journey-spec my.module:my_scenario

Then, the stats component will know which additional stats you wish to
use.

The following mite modules provide their own statistics:

- ``mite_selenium``

You can also write your own statistics; see the following section for
instructions on how.


Writing custom stats
--------------------

Prometheus, miteʼs chosen data backend, supports three different kinds
of metrics: a Gauge, a Counter, and a Histogram.

.. note::

   Prometheus also supports a Summary metric type, but this is just (for
   our purposes) a less performant version of a Histogram, so it will nt
   be further discussed.

Each of these is exposed as a class in the ``mite.stats`` module.  When
instantiating one of these classes to create a custom metric, you will
need to supply a name, a matcher, and an extractor.  The name is
directly translated into the prometheus name for the metric, so it is
useful for it to start with ``mite_`` so that related metrics will be
grouped together (especially if the prometheus instance that collects
your mite metrics also collects other data, like CPU and memory usage of
application processes).

The stats component acts by processing a stream of messages generated by
the runner and controller.  The matcher is a function that filters these
messages, determining which are of interest to a particular stat and
which it can ignore.  Because each message has a ``type`` field, it is
often useful to match on the value of that field, which is the purpose
of the included ``mite.stats.matcher_by_type`` function.  (However, the
matcher receives the entire message dict as an argument, and can perform
arbitrary computation on its contents if it wishes.)

The extractor function operates on the messages that have been selected
by the matcher.  The extractor pulls out some labels from the message,
which will be added as labels to the time series in prometheus.  It is
also, in most cases, responsible for extracting a numerical value from
the message.  (The exception is stats of the Counter type, which count
the occurrences of a particular message type.  There, no value dependent
on the message is needed, as the value of the counter is always
incremented by one).  The built-in ``mite.stats.extractor`` function
covers most use-cases.  It takes two arguments.  The first is a sequence
of strings, which will be extracted as keys from the message
dictionary.  The values of these keys will be used as the labels on the
prometheus metric.  The second argument is a single string, which names
the dictionary key containing the numeric value to be accumulated.  For
more advanced usages, it will be necessary to construct a
``mite.stats.Extractor`` class directly.  See
``mite.stats.controller_report_extractor`` for an example of this.

Here is an example of a custom stat from our work on AMQP testing:

.. code-block:: python

   def _amqp_extract(msg):
       for key, value in msg["total_received"].items():
           yield (key,), value


   _MITE_STATS = [
       Gauge(
           "mite_amqp_tx_stats",
           matcher_by_type("amqp_tx_stats"),
           extractor(["message_name"], "total_sent")
       ),
       Gauge(
           "mite_amqp_rx_stats",
           matcher_by_type("amqp_rx_stats"),
           Extractor(labels=["message_name"], extract=_amqp_extract)
       )
   ]

In our AMQP injection functions, we send two messages.  The first,
``amqp_tx_stats``, names a ``message_name`` and contains a
``total_sent`` value.  That is extracted into a Gauge by the first
stat.  Because each ``message_name`` is represented by a separate
message, this is a simple stat.  The second is the ``mite_rx_stats``.
This message is send by the worker coroutine that drains the AMQP
queues.  Once a second, it reports on the total number of messages it
has received – of all types.  Therefore, we need to write a custom
``_amqp_extract`` function, which will yield a sequence of ``(key,
value)`` tuples.

The ``_MITE_STATS`` variable name is a convention.  As discussed in the
previous section, it is possible to mark journey functions with a list
of modules from which extra stats will be imported.  This is implemented
by inspecting the ``_MITE_STATS`` attribute of each of these modules.
