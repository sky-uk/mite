# Finagle load injection for mite

This module contains the infrastructure for injecting load into finagle
services with mite.  Specifically, it implements the thrift binary RPC
format wrapped in finagleʼs mux framing protocol.  In order to use it
you must install mite with the `finagle` extra:
```
cd /path/to/mite
pip install ".[finagle]"
```

## Design

Unlike http which might be the paradigm of performance testing you are
most familiar with, finagle is an explicitly pipelined protocol.  It
would not be a realistic simulation of app behavior to open a new
connection for each finagle request.  So, we expose the finagle
connection explicitly as an (async) context manager:

```
from mite_finagle import mite_finagle

@mite_finagle
async def my_journey(ctx):
    async with ctx.finagle.connect("hostname", port=1234) as finagle:
        ...
```

(As is usual in mite, the `@mite_finagle` decorator dependency-injects a
finagle API object onto the first argument to the function which is a
context object)

Within the body of the context manager, the connection object has a few
methods available on it:

- `send`: sends as message to the finagle server.  It expects a message
  factory (see below) as well as `args` and `kwargs` to pass to the
  factory.  It accepts an additional kwarg `mux_context` which is a
  dictionary with `bytes` keys and values that represents the context
  passed with the finagle call.  (The context functions similarly to
  headers in an http request).  The send method does not wait for the
  reply.  It is designed to operate with the `replies` method.
- `send_and_wait`: sends the message, then waits for and returns the
  reply
- `replies`: an async generator that yields, in sequence, the reply
  objects received on the finagle connection.

The way this is designed to be used is to pre-seed a specific number of
messages (the desired tps) onto the finagle connection.  Then wait for
the replies, using the `chained_wait` functionality to wait the
appropriate amount of time (one second) before putting another message
into flight to maintain the tps.  You can think of this a bit like
juggling: there are always a certain number of balls in the air, and
when we “catch” a reply we need to (at the appropriate rate) “throw”
another message into the air:

```
for _ in range(desired_tps):
    finagle.send(factory, ...)
async for reply in finagle.replies():
    reply.chained_wait(1)
    finagle.send(factory, ...)
```

### Reply objects

The reply object is a thrift code-generated object.  In addition, it is
monkeypatched by mite_finagle with a `chained_wait` method.  The purpose
of this is to enable waiting for a specific period of time, starting
from when a message was sent (and not when the reply was received).
This allows controlling the rate of message injection.

Itʼs not the only possible method of rate control – we could use a
token bucket in concurrent processes for send+receive.  But a choice had
to be made.  Itʼs also worth noting that this implementation has
co-evolved with our finagle codebase which contains mostly methods that
return objects (or void) – itʼs likely that this doesnʼt work correctly
for methods that return non-objects (incl void, int, things like that).

### Message factories

The message factory abstraction encapsulates the knowledge that mite
needs about the thrift-level objects involved in making a finagle call:
the type of the request arguments and the return value.  It is
instantiated with two arguments: a method name and an autogenerated
thrift `Client` class which contains the code for invoking that method:

```
from my_module.MyService import Client

msg_factory = ThriftMessageFactory("my_method", Client)
```

Once the message factory is instantiated, it can be passed as an
argument to the `send` function (see above).  It has the below methods,
but itʼs unlikely (at the present point in time/design space) that mite
tests will need to invoke them for any reason:

- `get_(request|reply)_object`: convert from bytes into the
  request/reply to the factoryʼs method
- `get_(request|reply)_bytes`: get the serialization of a request/reply
  to the factoryʼs function.
- `get_reply_args`: get a kwargs dict of dummy values appropriate for
  passing to `get_reply_bytes` (useful for writing thrift stubs).

FIXME: the `get` verb in the above method names is heavily overloaded;
we probably want to do some renaming.

### Mux protocol code

## Testing

## TODOs / future extension

### Implicit connection cache

(an idea that just occurred to me while writing these docs, sigh)

One thing we could do, rather than exposing the finagle connection in
the way that this code does, is to enable an implicit process-level
connection pool.  Then we could write the finagle journeys just like we
write the http ones, but get the desired connection reuse behavior that
we want to simulate the finagle protocol.

### Better/more complete integration suite

What it says in the title

### Performance tests/characterization of the finagle code

What it says in the title

### Finish the reply object implemetation

The reply yielding code works OK when the reply is a thrift object and
(I hope – test this) `void`.  What is missing is:
- tests for the handling of int, list, etc return
- `chained_wait` for non-object returns

### Smarter handling of method arguments

Currently if we have a thrift method that takes lots of custom types in
its arguments, we need to import allthose from the thrift generated
code, and construct them ourselves.  Do we want to implement some sort
of clever coercion so that dicts (etc) can be transformed into the right
objects?  We have all the info we need to do this; itʼs just not plumbed
up (and idk if tiʼs a good idea or not).
