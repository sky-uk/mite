import asyncio
import time
from dataclasses import dataclass
from importlib import import_module
from itertools import count
from typing import Any

from thrift.protocol.TBinaryProtocol import TBinaryProtocol
from thrift.transport import TTransport

_SEQUENCE_NOS = count(1)


async def _result_wait(self, seconds):
    # Slightly weird -- a function with a `self` argument outside of a class.
    # This is not for calling directly; rather we will add it as an attribute
    # to the class representing the Thrift call result (which is generated
    # from thrift code, so we can't add the method in a "normal" way)
    if (sent_time := getattr(self, "_sent_time", None)) is None:
        print("sent_time not found")
        # This means we're in a weird racy universe.  We don't want to not
        # sleep at all, as that seems likely to make the races worse.  So
        # we'll do a small wait to try to stabilize.
        to_sleep = 0.1
    else:
        # The next line might look weird until you remember that `sent_time`
        # (like all variables in python) has function scope
        to_sleep = seconds - (time.time() - sent_time)
    if to_sleep > 0:
        await asyncio.sleep(to_sleep)
    else:
        # FIXME: log a warning
        pass


class _ThriftError:
    """A wrapper for thrift exceptions returned by Finagle"""

    def __init__(self, wrapped):
        self._wrapped = wrapped


# The official way to use the Client classes generated by Thrift is to
# instantiate them with an input and an output protocol and a sequence id, and
# to use them statefully.  Rather than do that, we'll create some proxy
# objects which have the properties needed to read or to write a message.  And
# then we will call the messages directly off of the class (not an instance),
# passing these proxies as the `self` argument.
@dataclass
class _ReadProxy:
    _iprot: Any


@dataclass
class _WriteProxy:
    _seqid: int
    _oprot: Any


class ThriftMessageFactory:
    """A factory class for thrift RPC messages.

    The `fn_name` is the name of the remote function we want to call.
    `client` should be a client class for the service we will be calling,
    generated by thrift.  `stats_name` allows giving a different name to these
    calls in the mite prometheus metrics.  It defaults to `fn_name`, but can
    be overridden in the case we are calling identically-named functions in
    different services.

    """
    def __init__(self, fn_name, client, stats_name=None):
        self._fn_name = fn_name
        self._client = client
        self._stats_name = stats_name or fn_name
        if getattr(client, fn_name, None) is None:
            raise Exception(
                f"wrong client passed when instantiating message factory for: {fn_name}"
            )
        # Monkeypatch the chained_wait method onto the reply class
        module = import_module(client.__module__)
        reply_class = getattr(module, fn_name + "_result").thrift_spec[0][3][0]
        reply_class.chained_wait = _result_wait
        # FIXME: this doesn't cover cases where functions have multiple
        # arguments.  Most (all) the cybertron thrift services have a single
        # struct as the first argument, but technically we're not as generic
        # as we need to be...
        self._args_struct = getattr(module, fn_name + "_args").thrift_spec[1][3][0]

    def get_request_bytes(self, *args, **kwargs):
        """Get the bytes representing a serialized request to the RPC function.

        `args` and `kwargs` are passed to the constructor for the request
        arguments.

        """
        out_msg = self._args_struct(*args, **kwargs)
        seq_no = next(_SEQUENCE_NOS)
        trans = TTransport.TMemoryBuffer()
        proto = TBinaryProtocol(trans)
        proxy = _WriteProxy(seq_no, proto)
        getattr(self._client, "send_" + self._fn_name)(proxy, out_msg)
        return trans._buffer.getvalue()

    def get_reply_object(self, msg):
        """Deserialize a reply from the bytes `msg`.

        If the call resulted in an exception, it will be returned wrapped in a
        `_ThriftError`.

        """
        trans = TTransport.TMemoryBuffer(msg)
        proto = TBinaryProtocol(trans)
        proxy = _ReadProxy(proto)
        try:
            result = getattr(self._client, "recv_" + self._fn_name)(proxy)
        except Exception as e:
            print("finagle error", str(e))
            result = _ThriftError(e)
        return result
